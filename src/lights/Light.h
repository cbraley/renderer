#ifndef LIGHT_H
#define LIGHT_H

#include "color/Spectrum.h"
#include "lights/VisibilityTester.h"
//class Shape; //Forward declaration to avoid circular include
#include "primitives/Shape.h"

//TODO: Make the base Light class store the Transform
//that places the light into the world.

/**
 *  Base class for all light sources.  Various light types must implement
 *  the interface of pure virtual functions found within.
 */
class Light{
public:

    /**
     *  Compute the total power of the light source (radiant flux).
     *  Unit is Watts.
     */
    virtual float totalPower()const = 0;

    /**
     *  Get spectral power at wavelength nm.
     *  Unit is Watts/nm.
     *  @param nm is the wavelength at which to get spectral power.
     */
    float spectralPower(float nm)const;

    /**
     *  Get the base SPD of the light source.
     *  Each sample of the SPD is spectral power per wavelength.
     *  @return the spectral power distribution.
     */
    virtual Spectrum getSPD()const = 0;

    /**
     *  Get the reccomended number of visibility samples.
     *  1 for a point source, more for an area light.
     */
    virtual int getRecNumVisibilitySamples()const = 0;

    /**
     *  Get nSamps random samples along the shape of the light
     *  source.
     */
    virtual void getSamples(Point* arr, int nSamps)const = 0;


    /**
     *  Sample the incident spectral radiance generated by
     *  this light source at the location worldPoint in world space.
     *
     */
    virtual Spectrum sampleIncidentRadiance(
        const Point& worldPoint,
        const Vector& normal,
        const Point& lightSamplePt)const = 0;

    /**
     *  Return any geometry associated with this light.
     *  For lights with no physical area(point lights)
     *  return NULL.
     */
    virtual const Shape* getGeom()const{ return NULL; }


};

//Inline function definitions -------------------------------------------------

inline float Light::spectralPower(float nm)const{
    return (getSPD())(nm);
}
#endif //LIGHT_H

